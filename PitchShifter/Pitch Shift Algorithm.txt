먼저 FIFO 대기열에서 현재 STFT 프레임을 얻습니다. 
이것은 우리가 특정 입력 버퍼 크기를 강제로 사용하고 싶지 않기 때문에 필요합니다. 
이렇게하면 실제 피치 이동에 사용하는 FFT 프레임 크기와 관계없이 모든 데이터를 처리 할 수 ​​있습니다. 
데이터는 윈도우 화되고 [re, im] gFFTworksp 배열로 인터리빙되어 고속 푸리에 변환 알고리즘 smbFft ()에 의해 변환됩니다. 
이 FFT 알고리즘은 특히 효율적이지는 않습니다. 
루틴을 사용하는 방법을 보여주고 수정없이 컴파일 할 수 있습니다. 
나중에 FFT의 취향으로 바꿀 수 있습니다. smbFft ()는 DFT à Pied 기사의 끝에 있습니다.

이제 우리는 DFT 빈의 양수 및 음수 주파수에 대한 복잡한 출력을 갖추고 있습니다. 
원래 신호가 순전히 실제이므로 양의 주파수 만 필요합니다. 
직사각형에서 극좌표로 변환하여 크기와 위상으로 변환하고 인접한 두 STFT 프레임 간의 위상차에서 순간 빈 주파수를 얻습니다. 
그로부터 우리는 두 개의 인접한 프레임 사이에서 예상되는 주파수 의존적 진행을 추론하고 보상하고 진정한 부분 주파수를 얻습니다. 
제 피치 이동 프로세스를 수행 한 후 주파수 도메인 마법사를 실행 취소 한 다음 변환하여 새로 생성 된 시간 도메인 시퀀스로 돌아갑니다. 
[re, im] 배열을 디인터레이싱 한 후 윈도우 화 및 크기 조정은 입력 데이터가 있는 만큼의 출력 데이터가 있는지 확인하기 위해 데이터를 출력 큐에 넣습니다. 
글로벌 I / O 지연은 inFifoLatency 샘플입니다 
(즉, 출력 시작에 많은 무음 샘플이 포함됨을 의미합니다!). 파일에 데이터를 쓸 때이 점을 고려해야합니다.

주목할만한 점 : smbPitchShift () 루틴은 정적 변수를 사용하여 중간 결과를 저장합니다. 
이것은 다소 우아하지 않으며 대신 적절하게 할당되고 초기화 된 메모리로 교체해야합니다.
루틴 매개 변수에 대한 참고 사항 : 
루틴 smbPitchShift ()는 0.5 (한 옥타브 아래로)와 2 (한 옥타브 위로) 사이의 pitchShift 요소 값을 사용합니다. 
정확히 1의 값은 피치를 변경하지 않습니다. 
더 넓은 피치 시프트 범위가 필요한 경우 코드를 약간 조정해야합니다.
numSampsToProcess는 indata [0… numSampsToProcess-1]에서 얼마나 많은 샘플을 피치 시프트하고 outdata [0… numSampsToProcess-1]로 이동해야하는지 루틴에 알려줍니다.
샘플 수에 제한이 없습니다. 
두 버퍼는 동일 할 수 있습니다 (즉, 데이터를 제자리에서 처리 할 수 ​​있음). 
fftFrameSize는 처리에 사용되는 FFT 프레임 크기를 정의합니다. 
일반적인 값은 1024, 2048 및 4096입니다. 
44.1kHz의 샘플 레이트의 경우 일반적으로 1024의 값은 음성에 적합하고 2048의 값은 음악에 적합합니다. 
MAX_FFT_FRAME_LENGTH보다 작은 값일 수 있지만 다른 프레임 크기도 처리 할 수있는 FFT를 사용하지 않는 한 2의 거듭 제곱이어야합니다.